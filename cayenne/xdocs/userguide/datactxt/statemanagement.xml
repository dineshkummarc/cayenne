<document>
<title>User Guide - Using DataContext</title>
<toc name="toc-user-guide" chapter="6. Using DataContext"/>
<body>
    <section name="6. Using DataContext">
	<subsection name="6.3 DataObject State Management">
	
	<p>Arguably the second most important function of DataContext (first is 
		performing queries) is keeping track of changes made to the registered 
		DataObjects. "Registered" is a keyword here - registering an object 
		with DataContext is what gives this object its persistent qualities.</p>
	
	<subsection name="6.3.1 How to Register a DataObject">
	<p>Behind the scenes "registering an object" results in storing this object 
		in a map using its ObjectId as a key, setting "dataContext" property of 
		a DataObject to the current DataContext, and taking a snapshot of all 
		persistent properties to be able to track later modifications. Objects 
		can become "registered" in two ways:</p>
	<ul>
		<li>automatically when they are fetched via query API</li>
		<li>explicitly for the newly created objects</li>
	</ul>
	
	<p>Whenever a selecting query is executed by a DataContext, all fetched 
		objects are automatically registered with this DataContext. On the 
		other hand, newly created objects must be registered explicitly:</p>
	
<source>
import org.objectstyle.cayenne.access.DataContext;
...
DataContext context; // assume this exists

Artist artist = new Artist();
context.registerNewObject(artist);

// after the line above is executed, artist object acquired "persistent" behavior
// and is said to be "managed" by DataContext
</source>

	<p>This code can be simplified - object creation and registrations steps 
		can be combined in one method call:</p>
<source>
import org.objectstyle.cayenne.access.DataContext;
...
DataContext context; // assume this exists

Artist artist = (Artist) context.createAndRegisterNewObject(Artist.class);
</source>
	<p>This method relies on the presence of a no-argument constructor in the 
		DataObject class.</p>
		</subsection>
		
		<subsection name="6.3.2 Checking the State of Registered DataObjects">
		<p>State transitions of DataObjects from persistence point of view are discussed in the
		"Design" chapter. State of each individual object is described by an integer
		constant obtained via a call to <code>DataObject.getPeristenceState()</code>.
		Allowed states are defined as static variables in <a href=
		"../../api/cayenne/org/objectstyle/cayenne/PersistenceState.html">PersistenceState</a> class.</p>
		
		<p>When a new object is inserted to the DataContext as described above, it becomes "NEW":</p>
<source>
import org.objectstyle.cayenne.access.DataContext;
...
DataContext context; // assume this exists

// artist will become PersistenceState.NEW
Artist artist = (Artist) context.createAndRegisterNewObject(Artist.class);
</source>

		<p>When a DataContext is committed, such object  becomes "COMMITTED":</p>
<source>
// artist will become PersistenceState.COMMITTED
context.commitChanges();
</source>
		
		<p>When any of the attributes or relationships of the fetched or committed object are changed, such
		an object becomes MODIFIED:</p>
<source>
// this will change the object state to PersistenceState.MODIFIED
artist.setName("NewName");
</source>

		<p>When a fetched or committed object is explicitly deleted from the 
			DataContext, object becomes DELETED:</p>
<source>
// this will change the object state to PersistenceState.DELETED
context.deleteObject(artist);
</source>

		<p>DataContext is said to have changes if it has one or more registered objects in a state
		<code>PersistenceState.MODIFIED</code>, <code>PersistenceState.NEW</code> or <code>PersistenceState.DELETED</code>.  
		DataContext provides the following method to check if it has any changed objects:
		
		<ul>
			<li><code>public boolean <b>hasChanges()</b></code></li>
		</ul>
		
		There is also a way to obtain a list of changed objects in each one of the above states:</p>
		
		<ul>
			<li><code>public java.util.Collection <b>newObjects</b>()</code></li>
			<li><code>public java.util.Collection <b>deletedObjects</b>()</code></li>
			<li><code>public java.util.Collection <b>modifiedObjects</b>()</code></li>
		</ul>
		</subsection>
		
		<subsection name="6.3.3 Saving All Uncommitted DataObjects">
		<p>All of the uncommitted objects ("uncommitted" means "new", 
			"modified" or "deleted") are saved ("committed") to the database 
			with a single method call on the DataContext: </p>
		
		<ul>
			<li><code>public void <b>commitChanges()</b></code></li>
		</ul>
		
		<p>Method <code>commitChanges</code> takes care of building correct SQL 
			statements, generating primary keys and transactional behaviour. It 
			roughly follows this scenario:</p>
		
		<ul>
			<li>Checks if there are any changed objects.</li>
			<li>Checks if there are any NEW objects.</li>
			<li>Generates primary keys for any NEW objects that require autogenerated key.</li>
			<li>Builds any needed SELECT, UPDATE, DELETE queries.</li>
			<li>Starts the database transaction.</li>
			<li>Runs the queries.</li>
			<li>Commits transaction.</li>
			<li>Changes all committed objects state to PersistenceState.COMMITTED.</li>
			<li>Updates internally stored snapshots of the recently saved objects.</li>
		</ul>
		</subsection>
		
	        <subsection name="6.3.3 Undoing All Uncommitted Changes">
	        <p>There is a way for the DataContext to undo all uncommitted changes:
	        <ul>
			<li><code>public void <b>rollbackChanges()</b></code></li>
		</ul>
		
		This will restore the persistence state and the values of all registered objects
		to the values that objects had when they were fetched or the last <code>commitChanges</code> 
		was executed. This effectively restores previously committed state of the object graph.
		Note that any NEW objects are unregistered from the context.		
	        </p>
		</subsection>
	</subsection>
    </section>
</body>
</document>
