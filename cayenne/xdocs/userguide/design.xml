<document>
<title>User Guide - Design</title>
<body>
    <section name="3. Design" toc="/userguide/index.html">
        <subsection name="3.1 Object Relational Mapping" anchor="or_map">
            <p>Normally mapping is done between Java class and a database table. This 
            way instance of such class (an object) will map to a single database row.
            Some properties of such object (properties in a "JavaBeans" sense) would map 
            to table columns. For example String, and numeric properties. Other properties
            would map to database primary-foreign key relationships. Summarizing possible 
            mappings we have the following correspondence:</p>
            
            <ul>
                <li>Java class -&gt; database table</li>
                <li>"simple" class property -&gt; table column</li>
                <li>"complex" class property -&gt; related table via a database relationship</li>
            </ul>
            <ul>
                <li>Java object -&gt; row in a table</li>
                <li>"simple" object property value -&gt; value of column in a row</li>
                <li>"complex" object property value -&gt; another object or list of objects</li>
            </ul>
        
            <p>This way O/R 
            framework allows programmer to get access to an "object tree" - objects 
            interconnected via relationship properties. Object tree is a view of a subset
            of database data and relationships between this data - all without 
            the need to write SQL code in Java applications. The most important
            property of the object tree is its ability to be synchronized with the database.
            This works both ways - object tree can get updated when the database data has changed
            or database will be updated when an object tree was changed by the Java application.</p>
            
            <p>The above statement doesn't mean that Caynne would automatically poll the database for 
            the updated data, or automatically save the data. This would have killed the performance 
            of the application and made it unpredictable. Instead Java application is always in full 
            control of these operations.</p>            
        </subsection>
        
        <subsection name="3.2 Data Objects" anchor="do">
            <p> To Be Done </p>
        </subsection>
        
        <subsection name="3.3 Access Classes" anchor="access_classes">
            <p>Cayenne database access is structured in a layered manner. (Diagram
            needed). These Java classes are the main controllers of each layer in the
            access model: DataContext -&gt; DataDomain -&gt; DataNode. DataNode
            connects to a relational database via JDBC. Each higher layer of control
            is optional. Only DataNode layer is required for Cayenne to operate. Each
            higher layer serves as a controller for the underlying layer, adding more
            functionality. Here is responsibilities of each class:</p>
            <p><a href="../api/org/objectstyle/cayenne/access/DataNode.html">1.
            DataNode</a> - lowest layer controller class, closest to the database. Its
            functions are (some of them are delegated to helper classes):</p>
            
            <ul>
                <li><i>Connects to JDBC datasource.</i> Provides advanced
                connection management functionality like connection pooling, etc.</li>
                
                <li>convert <a href=
                "../api/org/objectstyle/cayenne/query/Query.html">Query</a>
                objects into SQL statements and execute them</li>
                
                <li>convert JDBC ResultSets into <a href=
                "../api/org/objectstyle/cayenne/DataObject.html">DataObjects</a></li>
                
                <li>generate primary keys for the newly inserted objects</li>
            </ul>
            
            <p><a href="../api/org/objectstyle/cayenne/access/DataDomain.html">
            2. DataDomain</a> - second layer controller class on top of DataNode.
            Provides following functionality:</p>
            <ul>
                <li><i>Combines physical datasources (DataNodes) into a logical
                datasource.</i> For example, when an application fetches data from
                more then 1 database, programmer need not to be concerned with the
                details of connection management. DataDomain will route all queries
                to appropriate DataNode for execution.</li>

                <li><i>Allows to manage datasource <b>groups</b>.</i> This is the
                advanced scenario and may not be used all that often, but imagine a
                case of web application hosting. A single application may need to
                serve multiple companies. Each company would have their own set of
                databases. For each one of such sets, a DataDomain will be
                configured. When a user of such application starts a new session,
                application code will need to decide (based on some criteria, like user
                login id, virtual host URL, etc.) which company this user belongs to,
                and assign a corresponding DataDomain to a session. This way user
                view of the database is locked within her company area. &quot;
                Domain&quot; is a rather arbitrary term that we coined to describe
                such area. Most of the time all users will work with the same set of
                datasources. In this case application will use something called &quot;
                default domain&quot; shared by all users.</li>

                <li><i>Serves
                as a factory for both lower level DataNodes as well as higher level
                DataContexts</i>.</li>
            </ul>
            
            <p><a href="../api/org/objectstyle/cayenne/access/DataContext.html">3.
            DataContext</a> - highest layer controller class. This is the class directly
            accessed by users in most cases. Provides <a href=
            "../api/org/objectstyle/cayenne/DataObject.html">DataObjects</a>
            management including these functions:</p>
            
            <ul>
                <li><i>Isolation of object changes</i>. DataObjects with uncommitted
                changes are tracked in the context. Changes are not visible outside
                the context.</li>
                
                <li><i>Commits in 1 line of code</i>. If you have a bunch of
                DataObjects that you modified (changed attribute values, created new
                objects from scratch, marked objects as deleted), it would nice to
                commit them all at once without writing any SQL (or even without
                creating a bunch of Query objects). DataContext tracks all changes to
                objects, so it will do this for you. Just call &quot;<a href=
                "../api/org/objectstyle/cayenne/access/DataContext.html#commitChanges()">
                commitChanges</a>&quot;.</li>
		</ul>
        </subsection>
        
        <subsection name="3.4 Configuration" anchor="config">
            <p>Central piece in Cayenne configuration is 
            <a href="../api/org/objectstyle/cayenne/conf/Configuration.html">Configuration</a>
            class. It creates DataDomain objects used later to access the database. Database
            access is configured based
            on the data found in Cayenne configuration files.
            By default Configuration uses singleton model, i.e. normally there is only one 
            instance of Configuration (or its subclass) that exists in the application. This
            shared instance can be accessed via a static method like that:
            </p>
            
<source>import org.objectstyle.cayenne.conf.Configuration;
...           
Configuration conf = Configuration.getSharedConfig();
</source>
            <p>By default shared object returned will be an instance of 
            <a href="../api/org/objectstyle/cayenne/conf/DefaultConfiguration.html">DefaultConfiguration</a>.
            User can create her own subclasses of Configuration and use them instead. Main reason for creating 
            your own subclass is to load configuration files from non-standard locations.
            For example, in addition to DefaultConfiguration, Cayenne framework provides
            <a href="../api/org/objectstyle/cayenne/conf/ServletConfiguration.html">ServletConfiguration</a>
            class that, among other things, is able to locate resources relative to WEB-INF directory
            of a deployed web application. More information on the types and locations of configuration 
            files can be found in 
            <a href="../userguide/appguide/deploy.html">Deployment Chapter</a>.
            </p>
            
            <p>To make sure Cayenne 
            uses configuration object of the right class, you should add the following code
            somewhere in the application before any calls to Configuration where made: 
            </p>
            
<source>import org.objectstyle.cayenne.conf.Configuration
...
String myConfigSubclass = "my.package.ConfigSubclass";
Configuration.initSharedConfig(myConfigSubclass);
</source>
  
            <p>After that any subsequent calls to "getSharedConfig" will return an instance of your 
            class instead of DefaultConfiguration.
            </p>
        </subsection>
    </section>
</body>
</document>
