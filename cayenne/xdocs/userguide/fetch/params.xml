	<document>
<title>User Guide - Using SelectQueries</title>
<toc name="toc-user-guide" chapter="7. Using Queries"/> 
<body>
    <section name="7. Using Queries">        
        <subsection name="7.5 Parameterized Queries">
		<p>SelectQuery objects can be rather complex. They may contain big qualifiers
    	and lots of tuning parameters. <i>Parameterized Queries</i> is a feature in Cayenne
    	that addresses reusability of complex queries. With this feature, for each group of queries
    	that differ only in the values used in the qualifier, a developer may create a single shared
    	"prototype" query, and use it later as a factory for other queries. All settings
    	configured in the prototype object will be passed to the final queries. Qualifier of the 
    	prototype query may use named parameters that are substituted for real values when a final
    	query is created from the prototype. Each named parameter is an instance of <a href=
    	"../../api/cayenne/org/objectstyle/cayenne/exp/ExpressionParameter.html">ExpressionParameter</a>
    	class.
		</p>
		
		<subsection name="7.5.1 Using Parameterized Queries">                	
	<p>Here is an example of building a prototype query:</p>
<source>import java.util.List;
import java.util.ArrayList;
import org.objectstyle.cayenne.exp.Expression;
import org.objectstyle.cayenne.exp.ExpressionFactory;
import org.objectstyle.cayenne.query.SelectQuery;
...

// create a qualifier with two named parameters: 
//   "pname" and "aname"
List list = new ArrayList();
list.add(ExpressionFactory.matchExp("paintingTitle", 
         new ExpressionParameter("pname")));
list.add(ExpressionFactory.matchExp("toArtist.artistName", 
         new ExpressionParameter("aname")));
Expression qual = ExpressionFactory.joinExp(Expression.OR, list);

// build a prototype of a query
// "prototype" is simply another select query
SelectQuery proto = new SelectQuery(Painting.class, qual);
proto.setDistinct(true);
</source>

		<p>Prototype built in the example above can be used to create other queries. API used is:</p>
		<ul>
			<li>public SelectQuery <b>queryWithParameters</b>(Map parameters, boolean pruneMissing)<br/>
            Creates and returns a new SelectQuery using current query as a prototype. Map of 
            parameters is used to substitute named parameters in the qualifier with the real values.
            Returned query is a independent from the original prototype and can be customized at
            will. <code>pruneMissing</code> defines the method behavior for situations when 
            some of the named parameters don't have their values resolved in the provided map. 
            If set to <code>true</code>, Cayenne would prune expressions that can not be resolved.
            If set to <code>false</code>, the method would throw an exception if some of the values
            are missing.
            <p></p>
            </li>
            
			<li>public SelectQuery <b>queryWithParameters</b>(Map parameters)<br/>
            A shortcut for <code>public SelectQuery queryWithParameters(Map parameters, true)</code>.
            <p></p>
            </li>
        </ul>
        <p>Extending the example above, the following example shows how to
        build a query from a parameterized prototype:</p>
        
<source>import java.util.Map;
import java.util.HashMap;
import org.objectstyle.cayenne.query.SelectQuery;
...

SelectQuery proto = ... // this was built in the example above

// create a query
Map params1 = new HashMap();
params1.set("aname", "Dali");
SelectQuery query1 = proto.queryWithParameters(params1);

// further customize returned query 
// without affecting the prototype
query1.setFetchLimit(100);
... 

// create another query with a different set of parameters
Map params2 = new HashMap();
params2.set("aname", "Monet");
params2.set("pname", "The Beach at Trouville");
SelectQuery query2 = proto.queryWithParameters(params2);
... 

</source>
		</subsection>
		
		<subsection name="7.5.2 Assigning Parameterized Queries to Entities">
		<p>Parameterized queries are true prototype objects. They do not contain
		any contextual state information. Therefore they are suitable for the application-wide
		reuse. To simplify lookup of specific queries, Cayenne provides API to create 
		named queries associated with Entities in the DataMap. Queries can be 
		easily organized, and later located by the code that uses them. An example of 
		creating a named query is shown below. Such code is normally executed on application
		startup, before any DataContexts are created.		
		</p>
<source>
// this is a parameterized query initialized 
// similar to the previous examples
SelectQuery query; 

...

DataDomain domain = Configuration.getSharedConfig().getDomain();
ObjEntity ent = domain.getEntityResolver().lookupObjEntity(query);
ent.addQuery("MyQuery", query);
</source>

<p>Later, to find this query, called "MyQuery", the following code may be used 
(assuming that the query fetches Artists):
</p>
<source>
// assume this exists
DataContext context; 

...

SelectQuery queryProto = 
      context.getEntityResolver().lookupQuery(Artist.class, "MyQuery");
</source>

		</subsection>       
        </subsection>
    </section>
</body>
</document>

