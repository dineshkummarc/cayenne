<document>
<title>User Guide - Writing Cayenne Applications</title>

    <properties>
        <author>Andrei Adamchik</author>
    </properties>
<navigator>
	<up>/userguide/index.html</up>
	<prev>/userguide/perform/index.html</prev>
	<next>/userguide/deploy/cdeploy.html</next>
</navigator>    
<body>
     <section name="10. Deployment">        
           <p>Cayenne application deployment is about configuring the application 
           so that in runtime it could find a main project file (cayenne.xml) and 
           associated resources, such as DataMaps and DataNode XML files.
           </p>
           
           <subsection name="10.1 Configuration" anchor="config">
           <p>Central piece in Cayenne deployment is <a href=
           "../../api/cayenne/org/objectstyle/cayenne/conf/Configuration.html">Configuration</a>
            class. It locates and loads all the mapping and configuration information required 
            for Cayenne runtime. By default Configuration uses singleton model, i.e. normally 
            there is only one instance of either Configuration (or its subclass) that exists 
            in the application. This shared instance can be accessed via a static method like that:
            </p>

<source>import org.objectstyle.cayenne.conf.Configuration;
import org.objectstyle.cayenne.access.DataDomain;
...           
Configuration conf = Configuration.getSharedConfig();
DataDomain domain = conf.getDomain();
</source>
        	</subsection>
        
           <subsection name="10.2 Standalone Applications" anchor="standalone">
               <p>In a standalone Java application, normally a <a href=
               "../../api/cayenne/org/objectstyle/cayenne/conf/DefaultConfiguration.html">DefaultConfiguration</a>
                will be used to locate and load configuration files. This approach
                does not require any additional steps. Shared configuration objects
                can simply be obtained by calling <code>getSharedConfig</code>:</p>
                
<source>import org.objectstyle.cayenne.conf.Configuration;
...           
Configuration conf = Configuration.getSharedConfig();
</source>
              <p>DefaultConfiguration will expect <code>cayenne.xml</code> file to be located 
              in the CLASSPATH. Same is true for datamaps referenced in <code>cayenne.xml</code>.
              Their location is resolved relative to CLASSPATH as well. To make these files available to
              Cayenne, you can simply include them in the root of your application jar file. 
              </p>
              
              <p>Location of the datasource files referenced in <code>cayenne.xml</code>
              depends on what factory was assigned to each datasource in <code>cayenne.xml</code>.
              Normally this would be a <a href=
               "../../api/cayenne/org/objectstyle/cayenne/conf/DriverDataSourceFactory.html"
               >org.objectstyle.cayenne.conf.DriverDataSourceFactory</a>. It would use
               the following lookup order to resolve location:
               
               <ul>
                  <li>Location is assumed to be a file relative to the user HOME 
                  directory (as defined by <code>user.home</code> system property).</li>
                  <li>Location is assumed to be a file relative to the current directory
                  from which the application was started.</li>
                  <li>Location is assumed to be a resource relative to CLASSPATH.</li>
               </ul>
               
               This lookup order makes configuration very flexible in that it separates
               datasource configuration files from the application distribution (jar file).
               A compiled application can be deployed as a jar file containing <code>cayenne.xml</code>
               and datamap files, without any datasource files.  This way a user wouldn't
               need to rebuild a jar for each of the target environments that has a 
               different database server or user id.
               </p>
               
               <p>
               Most common example of this feature is when a Java project needs to be deployed
               in development, test, and production environments. All a deployer would need to
               do is to create datasource files in the home directory of each of the servers. After that
               the same jar file can be deployed on any of them without any changes. 
               Another benefit of a separate datasource file is that database user name 
               and password information are not
               stored with the application (possibly in a shared repository) 
               and instead stored on each deployment machine. This provides better security.
              </p>

           </subsection>
           
           <subsection name="10.3 Web Applications" anchor="web">
               <p>When deploying an application in a web container, it is still possible 
               to use the procedure described for the standalone applications above.
               But Cayenne provides a better way to do that. Suggested way is to use <a href=
               "../../api/cayenne/org/objectstyle/cayenne/conf/BasicServletConfiguration.html"
               >BasicServletConfiguration</a> subclass of Configuration. It does <code>cayenne.xml</code>
               and datamap files lookup relative to the WEB-INF directory of a deployed application.
               Since WEB-INF is a standard place to put configuration files, this approach makes
               configuration cleaner and more maintainable.
               <i>Note that it will NOT search the CLASSPATH for configuration files.</i>              
               </p>
               
               <p>
               To get access to the resources under WEB-INF directory, Cayenne configuration object
               must get a hold of javax.servlet.ServletContext instance of the current application.
               There are a few different ways to achieve that:
               </p>
               
               <p><strong>Initialization Servlet.</strong> This is the most common approach
               - use <code>init</code> method of the very first servlet loaded
               in the application. Some people would even create a specialized initialization servlet for 
               this purpose. Here is the steps involved.</p>

<p>Startup servlet initialization code:</p>
<source>
package com.somepackage;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import org.objectstyle.cayenne.conf.BasicServletConfiguration;

public class MyServlet extends HttpServlet {
    public void init(ServletConfig config) throws ServletException {
        super.init(config);
  
        BasicServletConfiguration.initConfig(config.getServletContext());
        
        // do other initialization...
    }
...
</source>
            
<p>Configuring startup servlet in <code>web.xml</code>: </p>      
<source>...

&amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;myservl&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;com.somepackage.MyServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;load-on-startup&amp;gt;0&amp;lt;/load-on-startup&amp;gt;
&amp;lt;/servlet&amp;gt; 

...
</source>
               <p><strong>Using Context and Session Listeners</strong>.  Servlet Specification 2.3
               introduces a set of container events that can be sent to the interested
               listeners. Cayenne contains a subclass of BasicServletConfiguration called
               <a href=
               "../../api/cayenne/org/objectstyle/cayenne/conf/ServletConfiguration.html"
               >ServletConfiguration</a> that implements container listener interfaces
               and can be registered as a listener to initialize Cayenne on context 
               startup and to assign a new DataContext object to every new session
               created.</p>
               
               <panel name="Note:">
               Check if your container supports Servlet Specification 2.3. For instance Tomcat >= 4.0
               does, while Tomcat 3.3 only supports 2.2
               </panel> 

<p>Registering listener in <code>web.xml</code>: </p>      
<source>...

&amp;lt;listener&amp;gt;
   &amp;lt;listener-class&amp;gt;org.objectstyle.cayenne.conf.ServletConfiguration&amp;lt;/listener-class&amp;gt;
&amp;lt;/listener&amp;gt; 

...
</source>

<p>Obtaining session DataContext:</p>      
              
<source>
import org.objectstyle.cayenne.conf.ServletConfiguration;
import javax.servlet.http.HttpServletRequest;
...

// assume this exists
HttpServletRequest r;

// get session DataContext to perform database queries
DataContext ctxt = ServletConfiguration.getDefaultContext(r.getSession());
</source>
               </subsection>
               
			<subsection name="10.4 Customizing Configuration" anchor="custom">
				<p>A user can create her own subclass of Configuration and use it instead. 
				Custom subclasses are usually created to load configuration files from 
				non-standard locations, to automatically configure Cayenne during 
				certain events that happen in deployment containers, etc. Cayenne framework
				provides a few implementations of Configuration discussed later in this chapter.
				</p>

				<p>To ensure that Cayenne uses configuration object of the right class, 
				Configuration singleton must be initialized properly before any calls 
				to Configuration are made: 
            	</p>

<source>import org.objectstyle.cayenne.conf.Configuration
...
String myConfigSubclass = "my.package.ConfigSubclass";
Configuration.initSharedConfig(myConfigSubclass);
</source>

            	<p>After this code is executed any subsequent calls to "Configuration.getSharedConfig" 
            	will return an instance of the custom class instead of DefaultConfiguration.
            	</p>
			</subsection>
               
               
               <subsection name="10.5 Using JNDI" anchor="jndi">
               
                <p>In many cases it is desirable to connect to the database
                using a preconfigured DataSource accessible via JNDI. In this case,
                Cayenne DataNodes must be configured (in the Modeler, or manually) to use 
                JNDIDataSourceFactory. Steps to make a DataSource accessible via JNDI 
                are normally external to the application and depend on a container used.
                Here is an extract from a sample web application deployment descriptor (web.xml file). 
                It declares a JNDI resource named "jdbc/mydb" of type "javax.sql.DataSource". 
                </p>
                
<source>...

&amp;lt;listener&amp;gt;
   &amp;lt;listener-class&amp;gt;org.objectstyle.cayenne.conf.ServletConfiguration&amp;lt;/listener-class&amp;gt;
&amp;lt;/listener&amp;gt; 

...

&amp;lt;resource-ref&amp;gt;
   &amp;lt;res-ref-name&gt;jdbc/mydb&amp;lt;/res-ref-name&amp;gt;
   &amp;lt;res-type&gt;javax.sql.DataSource&amp;lt;/res-type&amp;gt;
   &amp;lt;res-auth&gt;Container&amp;lt;/res-auth&amp;gt;
&amp;lt;/resource-ref&amp;gt;
...</source>
                
             <p>For the users of Tomcat >= 4.0, here is a sample configuration of a single
             web application context that makes a datasource available to this web application
             under the JNDI name "jdbc/mydb". <i>Note that configuration
             below is most certainly incompatible with other containers and will work with Tomcat
             only.</i> This code may be inserted in $CATALINA_HOME/conf/server.xml file between 
             the &lt;Host&gt;...&lt;/Host&gt; tags.
             </p>
<source>
&amp;lt;Context path="/myapp" docBase="myapp" debug="1" reloadable="true" crossContext="true"&amp;gt;
    &amp;lt;Logger className="org.apache.catalina.logger.FileLogger" 
                   prefix="myapp-log." 
                   suffix=".txt" 
                   timestamp="true"/&amp;gt;
   
    &amp;lt;ResourceParams name="jdbc/mydb"&amp;gt;
            &amp;lt;parameter&amp;gt;
                &amp;lt;name&amp;gt;factory&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;org.objectstyle.cayenne.conn.ContainerPoolFactory&amp;lt;/value&amp;gt;
            &amp;lt;/parameter&amp;gt;
            
            &amp;lt;parameter&amp;gt;
                &amp;lt;name&amp;gt;username&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;user&amp;lt;/value&amp;gt;
            &amp;lt;/parameter&amp;gt;
            
            &amp;lt;parameter&amp;gt;
                &amp;lt;name&amp;gt;password&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;bla-bla&amp;lt;/value&amp;gt;
            &amp;lt;/parameter&amp;gt;
                
            &amp;lt;parameter&amp;gt;
                &amp;lt;name&amp;gt;driver&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;org.gjt.mm.mysql.Driver&amp;lt;/value&amp;gt;
            &amp;lt;/parameter&amp;gt;
            
            &amp;lt;parameter&amp;gt;
                &amp;lt;name&amp;gt;url&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;jdbc:mysql://dbserver/mydb&amp;lt;/value&amp;gt;
            &amp;lt;/parameter&amp;gt;
            
            &amp;lt;parameter&amp;gt;
                &amp;lt;name&amp;gt;min&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;1&amp;lt;/value&amp;gt;
            &amp;lt;/parameter&amp;gt;
            
            &amp;lt;parameter&amp;gt;
                &amp;lt;name&amp;gt;max&amp;lt;/name&amp;gt;
                &amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;
            &amp;lt;/parameter&amp;gt;
    &amp;lt;/ResourceParams&amp;gt;
&amp;lt;/Context&amp;gt;
</source>
           </subsection>      
    </section>
</body>
</document>
