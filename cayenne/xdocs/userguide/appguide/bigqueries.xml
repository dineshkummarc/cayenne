<document>
<title>User Guide - Writing Cayenne Applications</title>

    <properties>
        <author>Andrei Adamchik</author>
    </properties>
<navigator>
	<up>/userguide/index.html</up>
	<prev>/userguide/appguide/exp.html</prev>
	<next>/userguide/appguide/deploy.html</next>
</navigator>    
<body>
    <section name="5. Writing Cayenne Applications">        
		<subsection name="5.8 Handling Large Result Sets" anchor="big">
            <p>Working with tables that contain huge number of rows
            (from tens of thousands to millions) often causes performance problems with 
            traditional O/R approach. The reasons are obvious and in many cases are
            not specific to O/R, but rather common to any database application: </p>
            <ul>
            	<li>It takes lots of time to create objects from a 
            	large ResultSet returned from the database.</li>
            	<li>It takes lots of memory to store all objects from
            	a large ResultSet. Application may eventually run out of
            	memory and crash.</li>
            </ul>
           
            
            <p>There is no single design pattern that solves all these issues, therefore
            Cayenne offers a few solutions suitable for different cases.</p>
            
            <subsection name="5.8.1 Data Rows" anchor="data_rows">
            <p>DataObjects creation and registering with DataContext is an expensive operation.
            There are cases when only a few objects are really used, but the application still
            has to fetch a lot of objects. For instance when a user performs a search, result may
            contain thousands of records, but user will only check 2-3 of them. Cayenne allows
            programmers to explicitly disable objects creation for such cases. Results will be returned
            in the form of java.util.Map's. In Cayenne such maps are called <code>Data Rows</code>.
            </p>
            
            <p>Benefits of <code>Data Rows</code>: </p>
            <ul>
            	<li>Fetch speed increase. Our tests show 2x to 5x performance increase.</li>
            	<li>Using regular Cayenne query API.</li>
            	<li>Using same DataMaps.</li>
            	<li>Easy to convert to DataObjects.</li>
            </ul>
            
            <p>Data rows don't have all the object-oriented features of DataObjects. In 
            particular, data rows don't support relationships. It is easy to create a DataObject
            from a row though. See examples below.</p>
            
            <p>Data rows example: </p>
<source>
import java.util.List;
import java.util.Map;
import org.objectstyle.cayenne.access.DataContext;
import org.objectstyle.cayenne.query.SelectQuery;
import org.objectstyle.art.Artist;
...
DataContext ctxt;

// create a query returning data rows
SelectQuery q = new SelectQuery("Artist");
q.setFetchingDataRows(true);

List artistRows = ctxt.performQuery(q);

// since query was configured to return data rows,
// result list elements are java.util.Map's
Map row = (Map)artistRows.get(0);

// convert row to an artist
Artist artist = (Artist)ctxt.objectFromDataRow("Artist", row);
...
</source>
			</subsection>
            
            <subsection name="5.8.2 Read-Only Entities" anchor="ro">
            <p>There are some cases when objects are used for display only. For instance when
            Cayenne is used for statistical report generation, etc. 
            For such cases Cayenne allows marking ObjEntities as "read-only", so that
            DataContext could make an assumption that user will not modify its managed objects. 
            This allows to implement more straightforward and faster algorithms for objects creation.
            </p>
            
            <p>Benefits of <code>Read-Only</code> Entities:</p>
            <ul>
            	<li>Fetch speed increase. Our tests show 2x performance increase, that is comparable
            	to data rows.</li>
            	<li>Relationships and other benefits of having an object as opposed to a generic 
            	collection.</li>
            </ul>
            
            <p>An obvious drawback of "read-only" entities is of course the inability to make any 
            direct modifications to persistent objects.</p>            
            </subsection>
            
			<subsection name="5.8.3 ResultIterator: Incremental Data Processing" anchor="iterator">
			<p>There are cases when the result sets are so large that even when fetching data rows, 
			application can run out of memory. For instance, a user may be creating a report
			that requires in-memory processing of hundreds of thousands of database rows. 
			In such cases normal Cayenne behavior of reading the whole <code>java.sql.ResultSet</code> 
			in the memory before returning it to the user may result in an application exhausing all
			memory and crashing.</p>
			
			<p>Cayenne solves this by allowing to 
			obtain results in the form of <a href=
			"../../api/org/objectstyle/cayenne/access/ResultIterator.html"><code>ResultIterator</code></a>. 
			<code>ResultIterator</code> is connected
			to an open <code>java.sql.ResultSet</code>, therefore it's methods may throw checked 
			exceptions. ResultIterator returns data rows (not DataObjects) one at a time, reading them
			on demand from the open ResultSet. Each data row can be converted to a DataObject or accessed
			directly. <strong>Open ResultIterator locks the database connection, therefore 
			ResultIterator always requires explicit closing
			in the user code.</strong></p>
			
			<panel name="Note:">
			In web applications, programmers must ensure
			that no open ResultIterators are kept between HTTP requests. Failure to do so
			may result in too many database connections being locked, thus quickly exhausting 
			connection pool. In general, an application with Web GUI is NOT a good candidate
			for implementation using ResultIterators.
			</panel>
			
			<p>When working with open ResultIterator, users still can perform any other database
			operations: select queries, traversing object relationships, etc. Any parallel data
			operation will internally check out an unused connection from the connection pool
			as it would normally do, while ResultIterator still locks its own connection.
			</p>
			
			<p>ResultIterator annotated example: </p>
<source>
import java.util.List;
import java.util.Map;
import org.objectstyle.cayenne.access.DataContext;
import org.objectstyle.cayenne.access.ResultIterator;
import org.objectstyle.cayenne.query.SelectQuery;
import org.objectstyle.cayenne.CayenneException;
import org.objectstyle.art.Artist;
...
DataContext ctxt;

// create a usual query
SelectQuery q = new SelectQuery("Artist");
ResultIterator it = null;

// ResultIterator operations all throw checked CayenneException
try {
   // special "performIteratedQuery" method is used
   it = ctxt.performIteratedQuery(q);

   while(it.hasNextRow()) {
      // ResultIterator always returns data rows 
      Map row = it.nextDataRow();
      
      // do something with the row...
      ...
   }
}
catch(CayenneException ex) {
   ex.printStackTrace();
}
finally {
   try {
      // explicit closing of the iterator is required !!!
      it.close();
   }
   catch(CayenneException closeEx) {
       closeEx.printStackTrace();
   }
}
...
</source>
			</subsection>
            
			<subsection name="5.8.4 Paged Results" anchor="paged">
            <p>This feature is pending implementation in Cayenne.</p>
			</subsection>
        </subsection>
    </section>
</body>
</document>
