/* Generated By:JJTree: Do not edit this line. SimpleNode.java */

package org.objectstyle.cayenne.exp.parser;

import org.objectstyle.cayenne.exp.Expression;
import org.objectstyle.cayenne.exp.ExpressionException;

/**
 * <p>Some parts of the parser are based on OGNL parser,
 * copyright (c) 2002, Drew Davidson and Luke Blanshard.</p>
 */
abstract class SimpleNode extends Expression implements Node {
    protected Node parent;
    protected Node[] children;
    protected int id;
    protected ExpressionParser parser;

    protected Object value;

    SimpleNode(int i) {
        id = i;
    }

    SimpleNode(ExpressionParser p, int i) {
        this(i);
        parser = p;
    }

    void setValue(Object value) {
        this.value = value;
    }

    Object getValue() {
        return value;
    }

    protected String getExpressionOperator(int index) {
        throw new UnsupportedOperationException(
            "No operator for '" + ExpressionParserTreeConstants.jjtNodeName[id] + "'");
    }

    /**
     * Implemented for backwards compatibility with exp package.
     * @return
     */
    public String expName() {
        return ExpressionParserTreeConstants.jjtNodeName[id];
    }

    /** 
     * Flattens the tree under this node by eliminating any children that are 
     * of the same class as this node and copying their children to this node. 
     */
    protected void flattenTree() {
        boolean shouldFlatten = false;
        int newSize = 0;

        for (int i = 0; i < children.length; i++) {
            if (children[i].getClass() == getClass()) {
                shouldFlatten = true;
                newSize += children[i].jjtGetNumChildren();
            }
            else {
                newSize++;
            }
        }

        if (shouldFlatten) {
            Node[] newChildren = new Node[newSize];
            int j = 0;

            for (int i = 0; i < children.length; ++i) {
                Node c = children[i];
                if (c.getClass() == getClass()) {
                    for (int k = 0; k < c.jjtGetNumChildren(); ++k)
                        newChildren[j++] = c.jjtGetChild(k);
                }
                else {
                    newChildren[j++] = c;
                }
            }

            if (j != newSize) {
                throw new ExpressionException("Assertion error: " + j + " != " + newSize);
            }

            this.children = newChildren;
        }
    }

    protected void toStringBuffer(StringBuffer buffer) {
        buffer.append((parent == null) ? "" : "(");

        if ((children != null) && (children.length > 0)) {
            for (int i = 0; i < children.length; ++i) {
                if (i > 0) {
                    buffer.append(' ').append(getExpressionOperator(i)).append(' ');
                }

                ((SimpleNode) children[i]).toStringBuffer(buffer);
            }
        }

        if (parent != null) {
            buffer.append(")");
        }
    }

    public Object getOperand(int index) {
        Node child = jjtGetChild(index);

        // unwrap ASTScalar nodes - this is likely a temporary thing to keep it compatible
        // with QualifierTranslator. In the future we might want to keep scalar nodes
        // for the purpose of expression evaluation.
        return unwrapChild(child);
    }
    
    protected Object unwrapChild(Node child) {
        return(child instanceof ASTScalar) ? ((ASTScalar) child).getValue() : child;
    }

    public int getOperandCount() {
        return jjtGetNumChildren();
    }

    public void setOperand(int index, Object value) {
        throw new UnsupportedOperationException("'setOperand' not supported.");
    }

    public void jjtOpen() {
        // System.out.println("opened: " + this.getClass().getName());
    }

    public void jjtClose() {
        //System.out.println(
        //   "will close: " + this.getClass().getName() + "; " + jjtGetNumChildren());
    }

    public void jjtSetParent(Node n) {
        parent = n;
    }
    public Node jjtGetParent() {
        return parent;
    }

    public void jjtAddChild(Node n, int i) {
        if (children == null) {
            children = new Node[i + 1];
        }
        else if (i >= children.length) {
            Node c[] = new Node[i + 1];
            System.arraycopy(children, 0, c, 0, children.length);
            children = c;
        }
        children[i] = n;
    }

    public Node jjtGetChild(int i) {
        return children[i];
    }

    public int jjtGetNumChildren() {
        return (children == null) ? 0 : children.length;
    }
}
